<!DOCTYPE html>
<html>
    <head>
        <title>Sketch 001</title>
        <script src='three/three.min.js'></script>
        <script src='dat/dat.gui.min.js'></script>
    </head>
    <style type='text/css'>
        body {
            margin: 0;
        }
    </style>

    <body>
        <div id='container'></div>

        <script id='vertexShader' type='x-shader/x-vertex'>
            void main() {
                gl_Position = vec4(position, 1.0);
            }
        </script>

        <script id='fragmentShader' type='x-shader/x-fragment'>
            #ifdef GS_ES
                precision mediump float;
            #endif

            #define PI 3.1415927
            #define PI2 (PI * 2.0)

            // Environment parameters.
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_res_mouse;
            uniform float u_time;

            // Number of arms/orbits (how many quantization bins).
            uniform float u_n_arms;
            uniform float u_n_orbits;

            // Oscillation parameters.
            uniform float u_res_time_arm;
            uniform float u_res_time_orbit;

            uniform vec3 u_phase_arm;
            uniform vec3 u_freq_arm;

            uniform vec3 u_phase_orbit;
            uniform vec3 u_freq_orbit;

            // Amount of interpolation.
            uniform float u_interp;

            /*
                Random noise functions. TODO: Clean up a bit, maybe can
                simplify where I use noise and delay until the end?
            */

            float rand(vec2 co) {
                return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
            }

            float rand(vec3 co) {
                return fract(sin(dot(co.xyz, vec3(12.9898,78.233,54.9430))) * 43758.5453);
            }

            /*
                Color space.
            */

            vec3 rgb2hsv(vec3 c) {
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            /*
                Linear interpolation functions. TODO: Probably builtin? Does
                GLSL have any sort of template support?
            */

            float lerp(float x, float x1, float x2, float y1, float y2) {
                return (x - x1) / (x2 - x1) * (y2 - y1) + y1;
            }

            vec3 lerp(float x, float x1, float x2, vec3 y1, vec3 y2) {
                return (x - x1) / (x2 - x1) * (y2 - y1) + y1;
            }

            vec3 lerp(vec3 x, vec3 x1, vec3 x2, vec3 y1, vec3 y2) {
                return (x - x1) / (x2 - x1) * (y2 - y1) + y1;
            }

            vec3 lerp(vec3 x, vec3 x1, vec3 x2, float y1, float y2) {
                return (x - x1) / (x2 - x1) * (y2 - y1) + y1;
            }

            vec3 remap(vec3 x, vec3 xmin, vec3 xmax) {
                return (x - xmin) / (xmax - xmin);
            }

            float remap(float x, float xmin, float xmax) {
                return (x - xmin) / (xmax - xmin);
            }

            /*
                Quantization functions for values between 0.0 and 1.0. Lo for
                floor, ceil for high (next bin).

                TODO: Maybe there's a more generalizable way to do this that
                doesn't require 0-1 and is just as fast.
            */

            float quantlo(float val, float bins) {
                return floor(val * bins) / bins;
            }

            float quanthi(float val, float bins) {
                return ceil(val * bins) / bins;
            }

            vec2 quantlo(vec2 val, float bins) {
                return floor(val * bins) / bins;
            }

            vec2 quanthi(vec2 val, float bins) {
                return ceil(val * bins) / bins;
            }

            vec3 quantlo(vec3 val, float bins) {
                return floor(val * bins) / bins;
            }

            vec3 quanthi(vec3 val, float bins) {
                return ceil(val * bins) / bins;
            }

            /*
                Functions for computing per-channel oscillation for arms /
                orbits based on their per-channel speeds / phases.
            */

            vec3 timesin(vec3 speed, vec3 phase) {
                return sin(u_time * speed + phase * PI);
            }

            void main() {
                vec2 p = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;
                vec2 m = quantlo(u_mouse, u_res_mouse);
                vec2 p2m = p.xy - m.xy;

                vec2 p2b = p.xy - vec2(0.0, -0.5);
                vec2 p2i1 = p.xy - vec2(-0.5, 0.5);
                vec2 p2i2 = p.xy - vec2(0.5, 0.5);

                float r_b = length(p2b) / sqrt(2.0);
                float r_p = length(p) / sqrt(2.0);
                float t_p = (atan(p.y, p.x) + PI) / PI2;

                float r_p_i1 = length(p2i1) / sqrt(2.0);
                float r_p_i2 = length(p2i2) / sqrt(2.0);

                float r_m = length(p2m) / sqrt(2.0);
                float t_m = (atan(p2m.y, p2m.x) + PI) / PI2;

                float t_i1 = (atan(p2i1.y, p2i1.x) + PI) / PI2;
                float t_i2 = (atan(p2i2.y, p2i2.x) + PI) / PI2;
                float t_b_i1 = (atan(p2b.y, p2b.x) + PI) / PI2;
                float t_b_i2 = 1.0 - (atan(p2b.y, p2b.x) + PI) / PI2;
                float n_arms = u_n_arms;
                float n_orbits = u_n_orbits;

                // Calculate per-channel progress for arms/orbits. These should
                // end up between 1.0 and 0.0 for consistency.
                vec3 time_arm = timesin(u_freq_arm, u_phase_arm);
                vec3 time_orbit = timesin(u_freq_orbit, u_phase_orbit);

                vec3 time_arm_q = quantlo(time_arm, u_res_time_arm);
                vec3 time_orbit_q = quantlo(time_orbit, u_res_time_orbit);

                /*
                    Each spiral arm and orbit is a value between 0.0 and 1.0,
                    quantized based on how many of them there are. Colors are
                    then chosen from a 2D RGB noise map, using orbit/arm for
                    x/y.

                    *_q means quantized.
                    *_q_next is the next quantized bin for determining
                        lerping amounts.
                    *_q_next_mod is the next quantized bin, modulo 1.0 for
                        determining colors.
                */

                // Discrete spiral arms.
                vec3 arm = mod(t_m + r_p + time_arm_q, 1.0);    // Continuous.
                vec3 arm_q = quantlo(arm, n_arms);              // Quantized.
                vec3 arm_q_next = quanthi(arm, n_arms);         // Next bin.
                vec3 arm_q_next_mod = mod(arm_q_next, 1.0);     // Next arm.

                vec3 arm_i1 = mod(t_b_i2 + r_p_i1 + time_arm_q, 1.0);    // Continuous.
                vec3 arm_i1_q = quantlo(arm_i1, n_arms);              // Quantized.
                vec3 arm_i1_q_next = quanthi(arm_i1, n_arms);         // Next bin.
                vec3 arm_i1_q_next_mod = mod(arm_i1_q_next, 1.0);     // Next arm.

                vec3 arm_i2 = mod(t_b_i1 + r_p_i2 + time_arm_q, 1.0);    // Continuous.
                vec3 arm_i2_q = quantlo(arm_i2, n_arms);              // Quantized.
                vec3 arm_i2_q_next = quanthi(arm_i2, n_arms);         // Next bin.
                vec3 arm_i2_q_next_mod = mod(arm_i2_q_next, 1.0);     // Next arm.

                // Discrete orbits.
                vec3 orbit = mod(r_b + time_orbit_q, 1.0);      // Continuous.
                vec3 orbit_q = quantlo(orbit, n_orbits);        // Quantized.
                vec3 orbit_q_next = quanthi(orbit, n_orbits);   // Next bin.
                vec3 orbit_q_next_mod = mod(orbit_q_next, 1.0); // Next orbit.

                // 2D interpolation between orbits and arms.
                /*
                vec3 cll = vec3(
                    rand(vec2(orbit_q.r, arm_q.r)),
                    rand(vec2(orbit_q.g, arm_q.g)),
                    rand(vec2(orbit_q.b, arm_q.b))
                );

                vec3 chh = vec3(
                    rand(vec2(orbit_q_next_mod.r, arm_q_next_mod.r)),
                    rand(vec2(orbit_q_next_mod.g, arm_q_next_mod.g)),
                    rand(vec2(orbit_q_next_mod.b, arm_q_next_mod.b))
                );

                vec3 clh = vec3(
                    rand(vec2(orbit_q.r, arm_q_next_mod.r)),
                    rand(vec2(orbit_q.g, arm_q_next_mod.g)),
                    rand(vec2(orbit_q.b, arm_q_next_mod.b))
                );

                vec3 chl = vec3(
                    rand(vec2(orbit_q_next_mod.r, arm_q.r)),
                    rand(vec2(orbit_q_next_mod.g, arm_q.g)),
                    rand(vec2(orbit_q_next_mod.b, arm_q.b))
                );


                vec3 armp = remap(arm, arm_q, arm_q_next); //lerp(arm, arm_q, arm_q_next, 0.0, 1.0);
                vec3 orbitp = lerp(orbit, orbit_q, orbit_q_next, 0.0, 1.0);

                vec3 cinterp =
                    ((1.0 - orbitp) * (1.0 - armp)) * cll +
                    ((1.0 - orbitp) * armp) * clh +
                    (orbitp * (1.0 - armp)) * chl +
                    (armp * orbitp) * chh;
                */

                vec3 cll = vec3(
                    rand(vec3(orbit_q.r, arm_i1_q.r, arm_i2_q.r)),
                    rand(vec3(orbit_q.g, arm_i1_q.g, arm_i2_q.g)),
                    rand(vec3(orbit_q.b, arm_i1_q.b, arm_i2_q.b))
                );
                /*
                float clh = rand(vec3(orbit_q.b, arm_i1_q_next_mod.b, arm_i2_q_next_mod.b));
                float chl = rand(vec3(orbit_q_next_mod.b, arm_i1_q.b, arm_i2_q.b));
                float chh = rand(vec3(orbit_q_next_mod.b, arm_i1_q_next_mod.b, arm_i2_q_next_mod.b));
                */
                /*
                float armp = remap(arm.b, arm_q.b, arm_q_next.b);
                float orbitp = remap(orbit.b, orbit_q.b, orbit_q_next.b);
                float vinterp =
                    ((1.0 - orbitp) * (1.0 - armp)) * cll.b +
                    ((1.0 - orbitp) * armp) * clh +
                    (orbitp * (1.0 - armp)) * chl +
                    (armp * orbitp) * chh;
                */
                //vec3 cinterp = vec3(cll.r, cll.g, vinterp);

                // Interpolate based on the amount of interpolation desired.
                //gl_FragColor = vec4(hsv2rgb(mix(cll, cinterp, u_interp)), 1.0);
                gl_FragColor = vec4(cll, 1.0);
            }
        </script>

        <script>
            var container;
            var clock;
            var camera, scene, renderer;

            // Uniforms for fragment shader.
            var uniforms = {
                u_time: { type: 'f', value: 1.0, auto: true },
                u_resolution: { type: 'v2', value: new THREE.Vector2() },
                u_mouse: { type: 'v2', value: new THREE.Vector2() }
            };

            // Parameter sliders.
            var gui;
            var guiparams = {};
            var guifolders = {};

            /*
                All parameters, used for initializing both gui params and
                three.js uniforms. Type is three.js uniform type, value is the
                default value. Range is min, max, step for the gui sliders.
            */

            var params = {
                u_res_mouse: {
                    type: 'f', value: 1000, range: [2, 1000, 10],
                    label: 'mouse res.', folder: 'global'
                },
                u_interp: {
                    type: 'f', value: 0.5, range: [0.0, 1.0, 0.1],
                    label: 'interpolation', folder: 'global'
                },
                u_n_orbits: {
                    type: 'f', value: 1, range: [1, 500, 10],
                    label: 'count', folder: 'orbits'
                },
                u_phase_orbit: {
                    type: 'v3', value: [0.1, 0.1, 0.1], range: [0, 1, 0.1],
                    label: 'phase', folder: 'orbits'
                },
                u_freq_orbit: {
                    type: 'v3', value: [0.5, 1.1, 2.1], range: [0.01, 10, 0.01],
                    label: 'freq', folder: 'orbits'
                },
                u_res_time_orbit: {
                    type: 'f', value: 1000.0, range: [1, 1000, 1],
                    label: 'time res.', folder: 'orbits'
                },
                u_n_arms: {
                    type: 'f', value: 10, range: [1, 500, 10],
                    label: 'count', folder: 'arms'
                },
                u_phase_arm: {
                    type: 'v3', value: [0.1, 0.1, 0.1], range: [0, 1, 0.1],
                    label: 'phase', folder: 'arms'
                },
                u_freq_arm: {
                    type: 'v3', value: [2.1, 1.1, 0.5], range: [0.01, 10, 0.01],
                    label: 'freq', folder: 'arms'
                },
                u_res_time_arm: {
                    type: 'f', value: 1000.0, range: [1, 1000, 1],
                    label: 'time res.', folder: 'arms'
                }
            };

            init();
            animate();

            // Add all the uniforms from the params variable.
            function createUniforms() {
                for (var key in params) {
                    var p = params[key];

                    uniforms[key] = {
                        type: p.type,
                        value: p.type == 'f' ? p.value : new THREE.Vector3(
                            p.value[0], p.value[1], p.value[2]
                        )
                    };
                }
            }

            // Lazy method for updating all uniforms whenever any gui slider
            // changes.
            function updateUniforms() {
                for (var key in params) {
                    var p = params[key];

                    if (p.type == 'f')
                        uniforms[key].value = guiparams[key];
                    else if (p.type == 'v3') {
                        channels = 'rgb';
                        components = 'xyz';

                        for (var c = 0; c < channels.length; c++) {
                            uniforms[key].value[components[c]] = guiparams[
                                key + '_' + channels[c]
                            ];
                        }
                    }
                }
            }

            // Create all the parameter sliders, three for multi-channel.
            function createGUI() {
                gui = new dat.GUI({height: 13 * 32 - 1});
                gui.remember(guiparams);

                for (var key in params) {
                    var p = params[key];

                    if (!(p.folder in guifolders)) {
                        guifolders[p.folder] = gui.addFolder(p.folder);
                    }

                    if (p.type == 'f') {
                        guiparams[key] = p.value;
                        guifolders[p.folder].add(guiparams, key)
                            .min(p.range[0])
                            .max(p.range[1])
                            .step(p.range[2])
                            .name(p.label)
                            .onFinishChange(updateUniforms);
                    } else if (p.type == 'v3') {
                        var channels = 'rgb';

                        for (var c = 0; c < channels.length; c++) {
                            guiparams[key + '_' + channels[c]] = p.value[c];

                            guifolders[p.folder]
                                .add(guiparams, key + '_' + channels[c])
                                .min(p.range[0])
                                .max(p.range[1])
                                .step(p.range[2])
                                .name(p.label + ' (' + channels[c] + ')')
                                .onFinishChange(updateUniforms);
                        }
                    }
                }

                for (var folder in guifolders) {
                    guifolders[folder].open();
                }
            }

            // Make everything go.
            function init() {
                container = document.getElementById('container');
                camera = new THREE.Camera();
                camera.position.z = 1;

                clock = new THREE.Clock();
                clock.start();

                createUniforms();
                createGUI();

                scene = new THREE.Scene();
                var geometry = new THREE.PlaneBufferGeometry(2, 2);

                // TODO: Don't need the vertexShader?
                var material = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent
                });

                // TODO: Maybe compositing is a better idea than putting both
                // spirals and arms in one shader?
                var mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                onWindowResize();
                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('mousemove', onMouseMove, false);
            }

            function onMouseMove(event) {
                uniforms.u_mouse.value.x = (event.clientX / window.innerWidth) * 2 - 1;
                uniforms.u_mouse.value.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            function onWindowResize(event) {
                renderer.setSize(window.innerWidth, window.innerHeight);

                uniforms.u_resolution.value.x = renderer.domElement.width;
                uniforms.u_resolution.value.y = renderer.domElement.height;
            }

            function animate() {
                requestAnimationFrame(animate);
                render();
            }

            function render() {
                uniforms.u_time.value = clock.getElapsedTime();
                renderer.render(scene, camera);
            }
        </script>
    </body>
</html>