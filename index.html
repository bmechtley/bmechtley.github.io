<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <script src="https://code.createjs.com/createjs-2015.05.21.min.js" type="text/javascript"></script>
        <style>
        	.cell {
        		stroke-width: 10;
        		stroke-linecap: round;
        	}

            .square {
                stroke-width: 10;
                stroke-linecap: square;
            }

        	svg {
        		background-color: white;
        		position: absolute;;
        		top: 0; 
        		left: 0;
        		width: 100vw;
        		height: 100vh;
        	}
        </style>
        <script>
        	var max_nbasecells = 20;
        	var min_nbasecells = 5;
        	var old_nbasecells = 5;
        	var nbasecells = 10;

            var channels = 4;
        	var columns = 10;
        	var rows = 20;
        	
        	var svg;

        	var cells = [];
            var squares = [];
        	var vals = [];
            var nvals = [];

            var effects = [];
            var mousedown = false;
        	var inverted = false;

            var rand = Math.random;

            // Helpers.
            function cellnum(r, c) {
            	return r * columns + c;
            }

            function hsl(h, s, l) {
                return 'hsl(' +
                    Math.floor(h) + ',' +
                    Math.floor(s) + '%,' +
                    Math.floor(l) + '%)'
            }

            function lerp(x, xlo, xhi, ylo, yhi) {
                return (x - xlo) / (xhi - xlo) * (yhi - ylo) + ylo;
            }


        	function rearrange(event) {
        		w = window.innerWidth;
        		h = window.innerHeight;
        		if (w < h) {
	            	ratio = h / w;
	        		cwidth = Math.floor(w / nbasecells);
	        		rows = Math.floor(ratio * nbasecells);
	        		columns = nbasecells;
	        	} else {
	        		ratio = w / h;
	        		cwidth = Math.floor(h / nbasecells);
	        		columns = Math.floor(ratio * nbasecells);
	        		rows = nbasecells;
	        	}

	        	margin = Math.ceil(cwidth * 0.1);

        		var cellidx = 0;

        		for (var c = 0; c < columns; c++) {
        			for (var r = 0; r < rows; r++) {
        				cellidx = cellnum(r, c);

        				cell = cells[cellidx];
        				cell.setAttribute('x1', c * (cwidth + margin));
        				cell.setAttribute('x2', c * (cwidth + margin));
        				cell.setAttribute('y1', r * (cwidth + margin));
        				cell.setAttribute('y2', r * (cwidth + margin));
        				cell.style['stroke-width'] = cwidth;

                        square = squares[cellidx];
                        square.setAttribute('x1', c * (cwidth + margin) - margin / 4);
                        square.setAttribute('x2', c * (cwidth + margin) + 3 * margin / 4);
                        square.setAttribute('y1', r * (cwidth + margin) - margin / 4);
                        square.setAttribute('y2', r * (cwidth + margin) - margin / 4);
                        square.style['stroke-width'] = cwidth + margin;

        			}
        		}

        		for (var i = cellidx + 1; i < cells.length; i++) {
        			cell = cells[i];
        			cell.style['stroke-width'] = 0;

                    square = squares[i];
                    square.style['stroke-width'] = 0;
        		}
        	}

            function iterate_cells(effect, fun) {
                for (var r = 0; r < rows; r++) {
                    for (var c = 0; c < columns; c++) {
                        for (var ch = 0; ch < channels; ch++) {
                            p = {
                                r: r, c: c, ch: ch,
                                effect: effect,
                                up: (rows + r - 1) % rows,
                                down: (rows + r + 1) % rows,
                                left: (columns + c - 1) % columns,
                                right: (columns + c + 1) % columns
                            }

                            p.v = [
                                [
                                    vals[cellnum(p.up, p.left)][ch],
                                    vals[cellnum(p.up, p.c)][ch],
                                    vals[cellnum(p.up, p.right)][ch]
                                ],
                                [
                                    vals[cellnum(p.r, p.left)][ch],
                                    vals[cellnum(p.r, p.c)][ch],
                                    vals[cellnum(p.r, p.right)][ch],
                                ],
                                [
                                    vals[cellnum(p.down, p.left)][ch],
                                    vals[cellnum(p.down, p.c)][ch],
                                    vals[cellnum(p.down, p.right)][ch]
                                ]
                            ]

                            fun(p);
                        }
                    }
                }
            }

            function swap(row1, col1, row2, col2, lt, channel) {
                a = vals[cellnum(row1, col1)][channel];
                b = vals[cellnum(row2, col2)][channel];

                if ((lt && a < b) || (!lt && a > b)) {
                    nvals[cellnum(row1, col1)][channel] = b;
                    nvals[cellnum(row2, col2)][channel] = a;
                }
            }

            function copy_pixels() {
                for (var r = 0; r < rows; r++) {
                    for (var c = 0; c < columns; c++) {
                        for (var ch = 0; ch < channels; ch++)
                            vals[cellnum(r,c)][ch] = nvals[cellnum(r,c)][ch];
                    }
                }
            }

            function randomize_direction(effect) {
                var pr = effect.pRange;

                for (var ch = 0; ch < channels; ch++) {
                	randval = rand();

                  	if (randval < effect.p[ch]) {
                        effect.direction[ch] = Math.floor(rand() * 3) - 1;
                       	effect.p[ch] = lerp(rand(), 0, 1, pr[0], pr[1]);
                   	}
                }
            }

            function init() {
            	svg = document.getElementsByTagName('svg')[0];

	        	for (var i = 0; i < max_nbasecells * (max_nbasecells * 100); i++) {
                    square = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    square.className = 'square';
                    square.style['stroke-width'] = 'none';
                    square.style['stroke-linecap'] = 'square';
                    square.id = 'square_' + i;
                    svg.appendChild(square);
                    squares.push(square);

	        		cell = document.createElementNS('http://www.w3.org/2000/svg', 'line');
	        		cell.className = 'cell';
	        		cell.style['stroke-width'] = 'none';
	        		cell.style['stroke-linecap'] = 'round';
	        		cell.id = 'cell_' + i;
	        		svg.appendChild(cell);
	        		cells.push(cell);


	        		vals.push([0, 0, 0, 0]);
	        		nvals.push([0, 0, 0, 0])
	        	}

                createjs.Ticker.addEventListener("tick", tick);
                createjs.Ticker.setFPS(10);
                svg.addEventListener("mousedown", function() {mousedown=true;});
                svg.addEventListener("mouseup", function() {mousedown=false;});

                var clear = {
                	direction: [-1, -1, -1, -1],
                	p: [0.01, 0.01, 0.01, 0.01],
                	pRange: [0.05, 0.5],
                	updatePixels: function(p) {
            			if (!mousedown && ((p.effect.direction[p.ch] == -1 && p.r == 0) || (p.effect.direction[p.ch == 1] && p.c == 0))) {
            				nvals[cellnum(p.r,p.c)][p.ch] = nvals[0][p.ch];
            			}
                	}
                }
                var automata = {
                    direction: [-1, -1, -1, -1],
                    p: [0.1, 0.1, 0.1, 0.1],
                    pRange: [0.05, 0.5],
                    updatePixels: function(p) {
                        if (p.effect.direction[p.ch] != 0 && !mousedown) {
                            drow = p.effect.direction[p.ch] + 1;

                            nvals[cellnum(p.r,p.c)][p.ch] = (
                                (p.v[1][0] + p.v[1][1] + p.v[1][2]) / 2 +
                                (p.v[drow][0] + p.v[drow][1] + p.v[drow][2]) / 2
                            ) % 100;
                        }
                    },
                    postUpdate: function(effect) {
                        if (!mousedown) {
                            copy_pixels();
                            randomize_direction(effect);
                        }
                    }
                };

                var invert = {
                	direction: [-1, -1, -1, -1],
                	p: [0.1, 0.1, 0.1, 0.1],
                	pRange: [0.05, 0.2],
                	updatePixels: function(p) {},
                	postUpdate: function(effect) {
                		randomize_direction(effect);
                		if (effect.direction[0] == -1 && !mousedown) {
                			inverted = true;
                		} else if (effect.direction[0] == 1 && !mousedown) {
                			inverted = false;
                		} else if (!mousedown) {
                			inverted = Math.round(rand());
                		}

                	}
                }

                var resize = {
                	direction: [-1, -1, -1, -1],
                	p: [0.1, 0.1, 0.1, 0.1],
                	pRange: [0.05, 0.5],
                	updatePixels: function(p) {},
                	postUpdate: function(effect) {
                		//copy_pixels();
                		randomize_direction(effect);
                		if (effect.direction[0] == -1 && !mousedown) {
                			old_nbasecells = nbasecells;
                			nbasecells = Math.floor(rand() * (max_nbasecells - min_nbasecells) + min_nbasecells);
                			rearrange();
                		}
                	}
                }

                var sort_horizontal = {
                    direction: [-1, -1, -1, -1],
                    p: [0.1, 0.1, 0.1, 0.1],
                    pRange: [0.05, 0.5],
                    updatePixels: function(p) {
                        if (p.effect.direction[p.ch] != 0) {
                           if (p.c < columns - 1) {
                                swap(
                                    p.r, p.c,
                                    p.r, p.right,
                                    p.effect.direction == -1 ? true : false,
                                    p.ch
                                );
                            }
                        }
                    },
                    postUpdate: function(effect) {
                        copy_pixels();
                        randomize_direction(effect);
                    }
                };

                var sort_vertical = {
                    direction: [-1, -1, -1, -1],
                    p: [0.1, 0.1, 0.1, 0.1],
                    pRange: [0.05, 0.5],
                    updatePixels: function(p) {
                        if (p.effect.direction[p.ch] != 0) {
                            if (p.r < rows - 1) {
                                swap(
                                    p.r, p.c,
                                    p.down, p.c,
                                    p.effect.direction == -1 ? true : false,
                                    p.ch
                                );
                            }
                        }
                    },
                    postUpdate: function(effect) {
                        copy_pixels();
                        randomize_direction(effect);
                    }
                }

                effects = [
                    clear, invert, resize, automata, sort_horizontal, sort_vertical
                ];
            }

            function tick() {
                /* Run each effect for each channel. */
                for (var e = 0; e < effects.length; e++) {
                    var effect = effects[e];

                    if (effect.hasOwnProperty('updatePixels'))
                        iterate_cells(effect, effect.updatePixels);

                    if (effect.hasOwnProperty('postUpdate'))
                        effect.postUpdate(effect);
                }

                /* Draw this frame. */
                for (var r = 0; r < rows; r++) {
                    for (var c = 0; c < columns; c++) {
                        cellno = cellnum(r, c);
                    	cell = cells[cellno];
                        square = squares[cellno];
                        val = vals[cellno];

                    	if (!inverted) {
	                        cell.style.stroke = hsl(
	                            Math.floor(lerp(val[0], 0, 100, 0, 360)),
	                            Math.floor(lerp(val[1], 0, 100, 33, 66)),
                                val[3] > 50 ? 
	                               Math.floor(lerp(val[2], 0, 100, 75, 100)) :
                                   Math.floor(lerp(val[3], 0, 100, 25, 0))
	                        );

                            square.style.stroke = hsl(
                                Math.floor(lerp(val[0], 0, 100, 360, 0)),
                                Math.floor(lerp(val[1], 0, 100, 66, 33)),
                                val[3] > 50 ? 
                                   Math.floor(lerp(val[3], 0, 100, 25, 0)) :
                                   Math.floor(lerp(val[2], 0, 100, 75, 100))
                            );

	                        svg.style['background-color'] = 'white';
	                    } else {
	                    	cell.style.stroke = hsl(
	                            Math.floor(lerp(val[0], 0, 100, 360, 0)),
	                            Math.floor(lerp(val[1], 0, 100, 66, 33)),
	                            val[3] > 50 ? 
                                   Math.floor(lerp(val[3], 0, 100, 25, 0)) :
                                   Math.floor(lerp(val[2], 0, 100, 75, 100))
	                        );

                            square.style.stroke = hsl(
                                Math.floor(lerp(val[0], 0, 100, 0, 360)),
                                Math.floor(lerp(val[1], 0, 100, 33, 66)),
                                val[3] > 50 ? 
                                   Math.floor(lerp(val[2], 0, 100, 75, 100)) :
                                   Math.floor(lerp(val[3], 0, 100, 25, 0))
                            );

	                        svg.style['background-color'] = 'black';
	                    }
                    }
                }
            }

            window.onload = function(event) {
	        	init();
	        	rearrange();

	        	for (var i = 0; i < columns; i++) {
	        		vals[cellnum(0, i)] = [rand() * 100, rand() * 100, rand() * 100, rand() * 100];
	        	}
	        }

        	window.onresize = rearrange;
        </script>
    </head>
    <body>
    	 <svg></svg>
    </body>
</html>

